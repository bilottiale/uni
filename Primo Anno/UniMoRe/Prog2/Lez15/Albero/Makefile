# Makefile per progetto Albero - Strutture Dati Alberi
# Implementazione di alberi con rappresentazione firstChild-nextSibling

# Configurazione compilatore
CXX = g++
CXXFLAGS = -std=c++14 -Wall -Wextra -g
TARGET = albero
SRCDIR = .
OBJDIR = obj

# File sorgenti e oggetti
SOURCES = main.cc tree.cc tipo.cc
OBJECTS = $(SOURCES:%.cc=$(OBJDIR)/%.o)
HEADERS = tree.h tipo.h

# Regola principale
all: $(OBJDIR) $(TARGET)

# Creazione directory oggetti
$(OBJDIR):
	mkdir -p $(OBJDIR)

# Regola per l'eseguibile finale
$(TARGET): $(OBJECTS)
	@echo "üå≥ Linking del progetto Albero..."
	$(CXX) $(CXXFLAGS) -o $(TARGET) $(OBJECTS)
	@echo "‚úÖ Compilazione completata: $(TARGET)"

# Regole per i file oggetto (con dipendenze dai headers)
$(OBJDIR)/main.o: main.cc tree.h tipo.h
	@echo "üî® Compilando main.cc..."
	$(CXX) $(CXXFLAGS) -c main.cc -o $(OBJDIR)/main.o

$(OBJDIR)/tree.o: tree.cc tree.h tipo.h
	@echo "üî® Compilando tree.cc..."
	$(CXX) $(CXXFLAGS) -c tree.cc -o $(OBJDIR)/tree.o

$(OBJDIR)/tipo.o: tipo.cc tipo.h
	@echo "üî® Compilando tipo.cc..."
	$(CXX) $(CXXFLAGS) -c tipo.cc -o $(OBJDIR)/tipo.o

# Versione debug (con output di debug abilitato)
debug: CXXFLAGS += -DDEBUG -O0
debug: clean $(TARGET)
	@echo "üêõ Build debug completato con flag DEBUG abilitato"

# Versione release (senza debug, ottimizzata)
release: CXXFLAGS += -DNDEBUG -O2
release: clean $(TARGET)
	@echo "üöÄ Build release completato (ottimizzato, no debug)"

# Pulizia
clean:
	@echo "üßπ Pulizia files generati..."
	rm -rf $(OBJDIR) $(TARGET)
	@echo "‚úÖ Pulizia completata"

# Pulizia completa (inclusi backup e temporanei)
distclean: clean
	rm -f *~ *.bak *.tmp core

# Esecuzione del programma
run: $(TARGET)
	@echo "üöÄ Esecuzione del programma Albero..."
	./$(TARGET)

# Esecuzione in modalit√† debug (mostra output di debug)
run-debug: debug
	@echo "üêõ Esecuzione in modalit√† debug..."
	./$(TARGET)

# Esecuzione in modalit√† release (senza output di debug)
run-release: release
	@echo "üöÄ Esecuzione in modalit√† release..."
	./$(TARGET)

# Debug con gdb
gdb: debug
	@echo "üîç Avvio debugger GDB..."
	gdb ./$(TARGET)

# Debug con valgrind (controllo memory leaks)
valgrind: debug
	@echo "üîç Controllo memory leaks con Valgrind..."
	valgrind --leak-check=full --show-leak-kinds=all ./$(TARGET)

# Informazioni sul progetto
info:
	@echo "üå≥ Informazioni Progetto Albero:"
	@echo "  Target: $(TARGET)"
	@echo "  Sorgenti: $(SOURCES)"
	@echo "  Headers: $(HEADERS)"
	@echo "  Oggetti: $(OBJECTS)"
	@echo "  Compilatore: $(CXX) $(CXXFLAGS)"
	@echo "  Struttura: Albero con rappresentazione firstChild-nextSibling"

# Controllo dipendenze headers
deps:
	@echo "üîç Analisi dipendenze:"
	@echo "  main.cc dipende da: tree.h tipo.h"
	@echo "  tree.cc dipende da: tree.h tipo.h"
	@echo "  tipo.cc dipende da: tipo.h"

# Controllo sintassi (solo compilazione, no linking)
check:
	@echo "‚úÖ Controllo sintassi di tutti i moduli..."
	$(CXX) $(CXXFLAGS) -c main.cc -o /dev/null
	$(CXX) $(CXXFLAGS) -c tree.cc -o /dev/null
	$(CXX) $(CXXFLAGS) -c tipo.cc -o /dev/null
	@echo "‚úÖ Tutti i moduli sono sintatticamente corretti"

# Analisi statica del codice
analyze:
	@echo "üîç Analisi statica del codice..."
	$(CXX) $(CXXFLAGS) -fsyntax-only -Wall -Wextra -Wpedantic main.cc tree.cc tipo.cc
	@echo "‚úÖ Analisi completata"

# Generazione documentazione con Doxygen (se disponibile)
docs:
	@if command -v doxygen >/dev/null 2>&1; then \
		echo "üìö Generazione documentazione con Doxygen..."; \
		doxygen -g Doxyfile.tmp; \
		echo "INPUT = ." >> Doxyfile.tmp; \
		echo "RECURSIVE = YES" >> Doxyfile.tmp; \
		doxygen Doxyfile.tmp; \
		rm Doxyfile.tmp; \
		echo "‚úÖ Documentazione generata in html/"; \
	else \
		echo "‚ùå Doxygen non installato. Installa con: brew install doxygen"; \
	fi

# Installazione (copia in /usr/local/bin)
install: release
	@echo "üì¶ Installazione in /usr/local/bin..."
	sudo cp $(TARGET) /usr/local/bin/
	@echo "‚úÖ Installazione completata"

# Backup del progetto
backup:
	@echo "üíæ Creazione backup..."
	tar -czf albero_backup_$(shell date +%Y%m%d_%H%M%S).tar.gz *.cc *.h Makefile
	@echo "‚úÖ Backup completato"

# Test della struttura albero
test: $(TARGET)
	@echo "üß™ Test della struttura Albero..."
	@echo "Creazione albero con nodi: Luca (root), Paolo, Marco, Lucia, Anna"
	./$(TARGET)
	@echo "‚úÖ Test completato"

# Benchmark performance (se necessario)
benchmark: release
	@echo "‚ö° Benchmark performance..."
	time ./$(TARGET)

# Help
help:
	@echo "üÜò Comandi disponibili:"
	@echo "  make all         - Compila il progetto completo"
	@echo "  make debug       - Compila in modalit√† debug"
	@echo "  make release     - Compila in modalit√† release"
	@echo "  make clean       - Rimuove files generati"
	@echo "  make run         - Compila ed esegue"
	@echo "  make run-debug   - Esegue in modalit√† debug"
	@echo "  make run-release - Esegue in modalit√† release"
	@echo "  make gdb         - Avvia con debugger GDB"
	@echo "  make valgrind    - Controllo memory leaks"
	@echo "  make check       - Controllo sintassi"
	@echo "  make analyze     - Analisi statica codice"
	@echo "  make test        - Test della struttura"
	@echo "  make docs        - Genera documentazione"
	@echo "  make info        - Informazioni progetto"
	@echo "  make deps        - Mostra dipendenze"
	@echo "  make backup      - Crea backup del progetto"
	@echo "  make install     - Installa in sistema"
	@echo "  make benchmark   - Test performance"
	@echo "  make help        - Mostra questo aiuto"

# Regole PHONY (non corrispondono a file)
.PHONY: all debug release clean distclean run run-debug run-release gdb valgrind info deps check analyze docs install backup test benchmark help

# Regola di default se si scrive solo 'make'
.DEFAULT_GOAL := all
