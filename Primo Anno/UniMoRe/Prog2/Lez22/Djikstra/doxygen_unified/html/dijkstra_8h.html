<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Algoritmo di Dijkstra e Modulo Grafo: dijkstra.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Algoritmo di Dijkstra e Modulo Grafo
   </div>
   <div id="projectbrief">Implementazione completa dell&#39;algoritmo di Dijkstra con supporto per grafi pesati</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('dijkstra_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">dijkstra.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implementazione completa dell'algoritmo di Dijkstra per percorsi minimi.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="grafo_8h_source.html">../../Lez20/grafo/grafo.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="codap_8h_source.html">codap.h</a>&quot;</code><br />
</div>
<p><a href="dijkstra_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac43cb1a224d4631ff2c336f60f142a52" id="r_ac43cb1a224d4631ff2c336f60f142a52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac43cb1a224d4631ff2c336f60f142a52">inizializza_dijkstra</a> (const grafo &amp;g, int sorgente, float *d, int *p)</td></tr>
<tr class="memdesc:ac43cb1a224d4631ff2c336f60f142a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inizializza le strutture dati per l'algoritmo di Dijkstra.  <br /></td></tr>
<tr class="memitem:a31f6e227fa7b83614cbe6b06d1524eb0" id="r_a31f6e227fa7b83614cbe6b06d1524eb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31f6e227fa7b83614cbe6b06d1524eb0">relax</a> (int u, int v, float peso, float *d, int *p, <a class="el" href="codap_8h.html#a48e727c6d4f1af018b0ce079b934a446">codap</a> &amp;q)</td></tr>
<tr class="memdesc:a31f6e227fa7b83614cbe6b06d1524eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rilassa un arco durante l'esecuzione dell'algoritmo di Dijkstra.  <br /></td></tr>
<tr class="memitem:a3c8180d11c01804b34fdd06326a97314" id="r_a3c8180d11c01804b34fdd06326a97314"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c8180d11c01804b34fdd06326a97314">dijkstra</a> (const grafo &amp;g, int sorgente, float *d, int *p)</td></tr>
<tr class="memdesc:a3c8180d11c01804b34fdd06326a97314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esegue l'algoritmo di Dijkstra per calcolare i percorsi minimi.  <br /></td></tr>
<tr class="memitem:a07e7a93fcb0f396bca38c30bdd605319" id="r_a07e7a93fcb0f396bca38c30bdd605319"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07e7a93fcb0f396bca38c30bdd605319">stampa_percorsi</a> (const float *d, const int *p, int n, int sorgente)</td></tr>
<tr class="memdesc:a07e7a93fcb0f396bca38c30bdd605319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stampa i risultati dell'algoritmo di Dijkstra in formato tabellare.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementazione completa dell'algoritmo di Dijkstra per percorsi minimi. </p>
<h1 class="doxsection"><a class="anchor" id="studio"></a>
Guida per lo Studio Universitario</h1>
<p>Questo file contiene le dichiarazioni delle funzioni per l'algoritmo di Dijkstra. Per una <b>analisi completa del codice riga per riga</b> consulta la documentazione principale che spiega:</p>
<ul>
<li>üîß <b>Ogni singola funzione</b> con esempi numerici</li>
<li>üìä <b>Strutture dati</b> (coda a priorit√†, array dinamici)</li>
<li>‚ö° <b>Complessit√† computazionale</b> di ogni operazione</li>
<li>üß† <b>Tecniche di programmazione</b> utilizzate</li>
<li>üéì <b>Concetti teorici</b> degli algoritmi</li>
<li>üêõ <b>Analisi critica</b> e miglioramenti possibili</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="algoritmo"></a>
Come Funziona l'Algoritmo di Dijkstra</h1>
<p>L'algoritmo trova i <b>percorsi minimi</b> da un nodo sorgente a tutti gli altri:</p>
<ol type="1">
<li><b>Inizializzazione</b>: dist[sorgente] = 0, dist[altri] = ‚àû</li>
<li><b>Coda a priorit√†</b>: Inserisce tutti i nodi ordinati per distanza</li>
<li><b>Ciclo principale</b>: Estrae nodo con distanza minima</li>
<li><b>Rilassamento</b>: Per ogni vicino, verifica se il percorso migliora</li>
<li><b>Aggiornamento</b>: Aggiorna distanze e coda a priorit√†</li>
<li><b>Ripetizione</b>: Fino a quando tutti i nodi sono visitati</li>
</ol>
<dl class="section author"><dt>Author</dt><dd>Progetto Programmazione 2 - UniMoRe </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 - Versione Studio Universitario </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2025 </dd></dl>

<p class="definition">Definition in file <a class="el" href="dijkstra_8h_source.html">dijkstra.h</a>.</p>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a3c8180d11c01804b34fdd06326a97314" name="a3c8180d11c01804b34fdd06326a97314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8180d11c01804b34fdd06326a97314">&#9670;&#160;</a></span>dijkstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dijkstra </td>
          <td>(</td>
          <td class="paramtype">const grafo &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sorgente</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esegue l'algoritmo di Dijkstra per calcolare i percorsi minimi. </p>
<p>Questa √® la funzione principale che implementa l'algoritmo di Dijkstra. Calcola le distanze minime da un nodo sorgente a tutti gli altri nodi raggiungibili nel grafo.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md3"></a>
Algoritmo Passo-Passo:</h3>
<ol type="1">
<li><b>Inizializzazione</b>:<ul>
<li>Imposta distanza[sorgente] = 0</li>
<li>Imposta distanza[altri] = INFINITO</li>
<li>Inserisce tutti i nodi nella coda a priorit√†</li>
</ul>
</li>
<li><b>Ciclo Principale</b>: <div class="fragment"><div class="line">MENTRE coda non √® vuota:</div>
<div class="line">    u = estrai_minimo(coda)</div>
<div class="line">    PER OGNI vicino v di u:</div>
<div class="line">        rilassa(u, v, peso(u,v))</div>
</div><!-- fragment --></li>
<li><b>Rilassamento</b>:<ul>
<li>Per ogni arco (u,v), verifica se il percorso u‚Üív migliora la distanza verso v</li>
<li>Se s√¨, aggiorna distanza[v] e predecessore[v]</li>
</ul>
</li>
</ol>
<h3 class="doxsection"><a class="anchor" id="autotoc_md4"></a>
Esempio Completo:</h3>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structgraph.html">graph</a> g = <span class="comment">/* grafo con 4 nodi */</span>;</div>
<div class="line"><span class="keywordtype">float</span> distanze[4];</div>
<div class="line"><span class="keywordtype">int</span> predecessori[4];</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#a3c8180d11c01804b34fdd06326a97314">dijkstra</a>(g, 1, distanze, predecessori);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Risultato:</span></div>
<div class="line"><span class="comment">// distanze[0] = 0    (nodo 1, sorgente)</span></div>
<div class="line"><span class="comment">// distanze[1] = 7    (nodo 2, distanza 7 da nodo 1)</span></div>
<div class="line"><span class="comment">// distanze[2] = 21   (nodo 3, distanza 21 via nodo 2)</span></div>
<div class="line"><span class="comment">// distanze[3] = 37   (nodo 4, distanza 37 via nodo 2)</span></div>
<div class="ttc" id="adijkstra_8h_html_a3c8180d11c01804b34fdd06326a97314"><div class="ttname"><a href="#a3c8180d11c01804b34fdd06326a97314">dijkstra</a></div><div class="ttdeci">void dijkstra(const grafo &amp;g, int sorgente, float *d, int *p)</div><div class="ttdoc">Esegue l&#39;algoritmo di Dijkstra per calcolare i percorsi minimi.</div></div>
<div class="ttc" id="astructgraph_html"><div class="ttname"><a href="structgraph.html">graph</a></div><div class="ttdoc">Struttura principale per rappresentare un grafo.</div><div class="ttdef"><b>Definition</b> <a href="grafo_8h_source.html#l00014">grafo.h:15</a></div></div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md5"></a>
Propriet√† Importante:</h3>
<p>Al termine dell'algoritmo, <span class="tt">distanze[i]</span> contiene la distanza minima dal nodo sorgente al nodo i+1, mentre <span class="tt">predecessori[i]</span> permette di ricostruire il percorso ottimo.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Il grafo pesato su cui eseguire l'algoritmo </td></tr>
    <tr><td class="paramname">sorgente</td><td>L'indice del nodo sorgente (1-based) </td></tr>
    <tr><td class="paramname">d</td><td>Array in cui verranno memorizzate le distanze minime (0-based) </td></tr>
    <tr><td class="paramname">p</td><td>Array in cui verranno memorizzati i predecessori (0-based)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Il grafo deve contenere solo archi con pesi non negativi </dd>
<dd>
sorgente deve essere un nodo valido (1 ‚â§ sorgente ‚â§ numero_nodi) </dd>
<dd>
Gli array d e p devono avere dimensione almeno pari al numero di nodi </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>d[i] contiene la distanza minima dal nodo sorgente al nodo i+1 </dd>
<dd>
p[i] contiene il predecessore del nodo i+1 nel percorso ottimo </dd>
<dd>
Se un nodo non √® raggiungibile, la sua distanza rimane INFINITO</dd></dl>
<p>@complexity Tempo: O((V + E) log V), Spazio: O(V) </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a31f6e227fa7b83614cbe6b06d1524eb0" title="Rilassa un arco durante l&#39;esecuzione dell&#39;algoritmo di Dijkstra.">relax()</a> per i dettagli sul rilassamento degli archi </dd>
<dd>
<a class="el" href="#ac43cb1a224d4631ff2c336f60f142a52" title="Inizializza le strutture dati per l&#39;algoritmo di Dijkstra.">inizializza_dijkstra()</a> per l'inizializzazione delle strutture dati </dd></dl>

</div>
</div>
<a id="ac43cb1a224d4631ff2c336f60f142a52" name="ac43cb1a224d4631ff2c336f60f142a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43cb1a224d4631ff2c336f60f142a52">&#9670;&#160;</a></span>inizializza_dijkstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inizializza_dijkstra </td>
          <td>(</td>
          <td class="paramtype">const grafo &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sorgente</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inizializza le strutture dati per l'algoritmo di Dijkstra. </p>
<p>Questa funzione prepara gli array delle distanze e dei predecessori prima dell'esecuzione dell'algoritmo. √à il primo passo fondamentale che:</p>
<ol type="1">
<li>Imposta tutte le distanze a INFINITO (FLT_MAX)</li>
<li>Imposta tutti i predecessori a NULL (nessun padre)</li>
<li>Imposta la distanza del nodo sorgente a 0</li>
</ol>
<h3 class="doxsection"><a class="anchor" id="autotoc_md0"></a>
Esempio:</h3>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> distanze[7];</div>
<div class="line"><span class="keywordtype">int</span> padri[7];</div>
<div class="line"><a class="code hl_function" href="#ac43cb1a224d4631ff2c336f60f142a52">inizializza_dijkstra</a>(grafo, 1, distanze, padri);</div>
<div class="line"><span class="comment">// Risultato: distanze[0] = 0, distanze[1..6] = INFINITO</span></div>
<div class="ttc" id="adijkstra_8h_html_ac43cb1a224d4631ff2c336f60f142a52"><div class="ttname"><a href="#ac43cb1a224d4631ff2c336f60f142a52">inizializza_dijkstra</a></div><div class="ttdeci">void inizializza_dijkstra(const grafo &amp;g, int sorgente, float *d, int *p)</div><div class="ttdoc">Inizializza le strutture dati per l&#39;algoritmo di Dijkstra.</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Il grafo su cui operare </td></tr>
    <tr><td class="paramname">sorgente</td><td>L'indice del nodo di partenza (1-based) </td></tr>
    <tr><td class="paramname">d</td><td>Array per memorizzare le distanze minime dalla sorgente </td></tr>
    <tr><td class="paramname">p</td><td>Array per memorizzare i predecessori nel percorso minimo</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Il grafo deve essere valido e inizializzato </dd>
<dd>
Gli array d e p devono avere dimensione almeno pari al numero di nodi </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>d[sorgente-1] = 0, tutti gli altri d[i] = FLT_MAX </dd>
<dd>
Tutti i p[i] sono inizializzati a NULL </dd></dl>

</div>
</div>
<a id="a31f6e227fa7b83614cbe6b06d1524eb0" name="a31f6e227fa7b83614cbe6b06d1524eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f6e227fa7b83614cbe6b06d1524eb0">&#9670;&#160;</a></span>relax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void relax </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>peso</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="codap_8h.html#a48e727c6d4f1af018b0ce079b934a446">codap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rilassa un arco durante l'esecuzione dell'algoritmo di Dijkstra. </p>
<p>Il <b>rilassamento</b> √® il cuore dell'algoritmo di Dijkstra. Per ogni arco (u,v), verifica se passare attraverso u offre un percorso pi√π breve verso v rispetto al percorso migliore conosciuto fino a quel momento.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1"></a>
Logica del Rilassamento:</h3>
<div class="fragment"><div class="line">SE distanza[v] &gt; distanza[u] + peso(u,v) ALLORA</div>
<div class="line">   distanza[v] = distanza[u] + peso(u,v)</div>
<div class="line">   predecessore[v] = u</div>
<div class="line">   aggiorna_coda_priorit√†(v, nuova_distanza)</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md2"></a>
Esempio Pratico:</h3>
<p>Supponiamo di avere:</p><ul>
<li>Nodo u=2 con distanza[2] = 7</li>
<li>Nodo v=3 con distanza[3] = 22</li>
<li>Arco 2‚Üí3 con peso 14</li>
</ul>
<p>Il rilassamento verifica: 22 &gt; 7 + 14 = 21? S√å! Quindi aggiorna: distanza[3] = 21, predecessore[3] = 2</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Nodo di partenza dell'arco (indice 0-based) </td></tr>
    <tr><td class="paramname">v</td><td>Nodo di destinazione dell'arco (indice 0-based) </td></tr>
    <tr><td class="paramname">peso</td><td>Peso dell'arco (u, v) - deve essere positivo </td></tr>
    <tr><td class="paramname">d</td><td>Array delle distanze correnti </td></tr>
    <tr><td class="paramname">p</td><td>Array dei predecessori </td></tr>
    <tr><td class="paramname">q</td><td>Coda a priorit√† dei nodi da visitare</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>peso &gt;= 0 (l'algoritmo di Dijkstra richiede pesi non negativi) </dd>
<dd>
u e v devono essere indici validi nel grafo </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Se il percorso √® migliorato: d[v] e p[v] vengono aggiornati </dd>
<dd>
La coda a priorit√† viene aggiornata con la nuova distanza di v </dd></dl>

</div>
</div>
<a id="a07e7a93fcb0f396bca38c30bdd605319" name="a07e7a93fcb0f396bca38c30bdd605319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e7a93fcb0f396bca38c30bdd605319">&#9670;&#160;</a></span>stampa_percorsi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stampa_percorsi </td>
          <td>(</td>
          <td class="paramtype">const float *</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sorgente</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stampa i risultati dell'algoritmo di Dijkstra in formato tabellare. </p>
<p>Questa funzione di utilit√† mostra i risultati dell'algoritmo in una forma facilmente leggibile, includendo per ogni nodo:</p><ul>
<li>Il numero del nodo (1-based)</li>
<li>La distanza minima dalla sorgente</li>
<li>Il nodo predecessore nel percorso ottimo</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6"></a>
Formato Output:</h3>
<div class="fragment"><div class="line">Nodo    Peso    Padre</div>
<div class="line">1       0       0      ‚Üê Nodo sorgente</div>
<div class="line">2       7       1      ‚Üê Raggiunto da nodo 1 con distanza 7</div>
<div class="line">3       21      2      ‚Üê Raggiunto da nodo 2 con distanza 21</div>
<div class="line">4       37      2      ‚Üê Raggiunto da nodo 2 con distanza 37</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7"></a>
Interpretazione:</h3>
<ul>
<li><b>Peso = 0</b>: Il nodo √® la sorgente</li>
<li><b>Peso = INFINITO</b>: Il nodo non √® raggiungibile dalla sorgente</li>
<li><b>Padre = 0</b>: Il nodo √® la sorgente (nessun predecessore)</li>
<li><b>Padre ‚â† 0</b>: Il nodo predecessore nel percorso ottimo</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8"></a>
Ricostruzione del Percorso:</h3>
<p>Per trovare il percorso dalla sorgente al nodo N:</p><ol type="1">
<li>Parti dal nodo N</li>
<li>Segui i predecessori all'indietro: N ‚Üí padre[N] ‚Üí padre[padre[N]] ‚Üí ...</li>
<li>Fermati quando raggiungi la sorgente (padre = 0)</li>
</ol>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9"></a>
Esempio di Ricostruzione:</h3>
<p>Per raggiungere il nodo 4 dalla sorgente 1:</p><ul>
<li>Nodo 4, padre = 2</li>
<li>Nodo 2, padre = 1 <br  />
</li>
<li>Nodo 1, padre = 0 (sorgente)</li>
<li><b>Percorso</b>: 1 ‚Üí 2 ‚Üí 4 (distanza totale: 37)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Array delle distanze calcolate da Dijkstra </td></tr>
    <tr><td class="paramname">p</td><td>Array dei predecessori calcolati da Dijkstra <br  />
 </td></tr>
    <tr><td class="paramname">n</td><td>Numero totale di nodi nel grafo </td></tr>
    <tr><td class="paramname">sorgente</td><td>Nodo di partenza dell'algoritmo (per riferimento)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Gli array d e p devono essere stati popolati dall'algoritmo di Dijkstra </dd>
<dd>
n deve corrispondere alla dimensione effettiva del grafo </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Stampa una tabella formattata con i risultati dell'algoritmo</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c8180d11c01804b34fdd06326a97314" title="Esegue l&#39;algoritmo di Dijkstra per calcolare i percorsi minimi.">dijkstra()</a> per il calcolo delle distanze e predecessori </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dijkstra_8h.html">dijkstra.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
