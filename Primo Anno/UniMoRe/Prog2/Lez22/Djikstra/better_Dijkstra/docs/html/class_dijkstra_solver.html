<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="it">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Algoritmo di Dijkstra - Versione Migliorata: Riferimenti per la classe DijkstraSolver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Algoritmo di Dijkstra - Versione Migliorata<span id="projectnumber">&#160;2.0</span>
   </div>
   <div id="projectbrief">Implementazione avanzata con std::priority_queue, RAII e gestione errori</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generato da Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Cerca',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('class_dijkstra_solver.html','','class_dijkstra_solver-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Caricamento in corso...</div>
<div class="SRStatus" id="Searching">Ricerca in corso...</div>
<div class="SRStatus" id="NoMatches">Nessun risultato</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Riferimenti per la classe DijkstraSolver</div></div>
</div><!--header-->
<div class="contents">

<p>Classe per il solver dell'algoritmo di Dijkstra migliorato.  
 <a href="#details">Continua...</a></p>

<p><code>#include &lt;<a class="el" href="better__dijkstra_8h_source.html">better_dijkstra.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Tipi pubblici</h2></td></tr>
<tr class="memitem:a84459ce731c874b7e431ee7432e9c49d" id="r_a84459ce731c874b7e431ee7432e9c49d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84459ce731c874b7e431ee7432e9c49d">DistanceNodePair</a> = std::pair&lt;float, int&gt;</td></tr>
<tr class="memdesc:a84459ce731c874b7e431ee7432e9c49d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tipo per rappresentare una coppia (distanza, nodo) nella priority queue.  <br /></td></tr>
<tr class="memitem:a3131a7b193d0d4e9bc956d97cb7b6fd1" id="r_a3131a7b193d0d4e9bc956d97cb7b6fd1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3131a7b193d0d4e9bc956d97cb7b6fd1">MinPriorityQueue</a></td></tr>
<tr class="memdesc:a3131a7b193d0d4e9bc956d97cb7b6fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Min-heap per estrarre sempre il nodo con distanza minima.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Membri pubblici</h2></td></tr>
<tr class="memitem:a7761580b64aa87474eb849fd1d076e63" id="r_a7761580b64aa87474eb849fd1d076e63"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7761580b64aa87474eb849fd1d076e63">DijkstraSolver</a> (const graph &amp;g)</td></tr>
<tr class="memdesc:a7761580b64aa87474eb849fd1d076e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Costruttore che inizializza il solver con un grafo.  <br /></td></tr>
<tr class="memitem:a338bdf5938d0cd6bab3e0e187f3a2dfb" id="r_a338bdf5938d0cd6bab3e0e187f3a2dfb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a338bdf5938d0cd6bab3e0e187f3a2dfb">~DijkstraSolver</a> ()=default</td></tr>
<tr class="memdesc:a338bdf5938d0cd6bab3e0e187f3a2dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distruttore (gestito automaticamente da std::vector)  <br /></td></tr>
<tr class="memitem:a533254b95fd3e4a2770ecbf2556c8e61" id="r_a533254b95fd3e4a2770ecbf2556c8e61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a533254b95fd3e4a2770ecbf2556c8e61">DijkstraSolver</a> (const <a class="el" href="class_dijkstra_solver.html">DijkstraSolver</a> &amp;)=delete</td></tr>
<tr class="memdesc:a533254b95fd3e4a2770ecbf2556c8e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disabilita copia per evitare problemi con riferimenti.  <br /></td></tr>
<tr class="memitem:ab636a7a375a793b57802f06bcfc2e020" id="r_ab636a7a375a793b57802f06bcfc2e020"><td class="memItemLeft" align="right" valign="top"><a id="ab636a7a375a793b57802f06bcfc2e020" name="ab636a7a375a793b57802f06bcfc2e020"></a>
<a class="el" href="class_dijkstra_solver.html">DijkstraSolver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_dijkstra_solver.html">DijkstraSolver</a> &amp;)=delete</td></tr>
<tr class="memitem:a0530094ff2b472cd61ae0c434d242991" id="r_a0530094ff2b472cd61ae0c434d242991"><td class="memItemLeft" align="right" valign="top"><a class="el" href="better__dijkstra_8h.html#abb8319303972e8177ba25f0310282cba">DijkstraError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0530094ff2b472cd61ae0c434d242991">computePaths</a> (int source)</td></tr>
<tr class="memdesc:a0530094ff2b472cd61ae0c434d242991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esegue l'algoritmo di Dijkstra con gestione errori completa.  <br /></td></tr>
<tr class="memitem:a20f6b913f55a3709f2b934500c899b5e" id="r_a20f6b913f55a3709f2b934500c899b5e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20f6b913f55a3709f2b934500c899b5e">getDistance</a> (int target) const</td></tr>
<tr class="memdesc:a20f6b913f55a3709f2b934500c899b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ottiene la distanza minima verso un nodo target.  <br /></td></tr>
<tr class="memitem:a98e1ac64ec4b2753485b57bb00da14c8" id="r_a98e1ac64ec4b2753485b57bb00da14c8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98e1ac64ec4b2753485b57bb00da14c8">getPath</a> (int target) const</td></tr>
<tr class="memdesc:a98e1ac64ec4b2753485b57bb00da14c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ricostruisce il percorso minimo verso un nodo target.  <br /></td></tr>
<tr class="memitem:a646e23da81edd3088d9b4cd8b7a5e9b2" id="r_a646e23da81edd3088d9b4cd8b7a5e9b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a646e23da81edd3088d9b4cd8b7a5e9b2">printResults</a> () const</td></tr>
<tr class="memdesc:a646e23da81edd3088d9b4cd8b7a5e9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stampa i risultati in formato tabellare leggibile.  <br /></td></tr>
<tr class="memitem:a43da24728dd38e829597c2e81ac59f1f" id="r_a43da24728dd38e829597c2e81ac59f1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43da24728dd38e829597c2e81ac59f1f">printPath</a> (const std::vector&lt; int &gt; &amp;path, int source, int target) const</td></tr>
<tr class="memdesc:a43da24728dd38e829597c2e81ac59f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stampa un percorso specifico in formato leggibile.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Membri pubblici statici</h2></td></tr>
<tr class="memitem:a59a9850164d41ddf1d116a0d7364985d" id="r_a59a9850164d41ddf1d116a0d7364985d"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59a9850164d41ddf1d116a0d7364985d">errorToString</a> (<a class="el" href="better__dijkstra_8h.html#abb8319303972e8177ba25f0310282cba">DijkstraError</a> error)</td></tr>
<tr class="memdesc:a59a9850164d41ddf1d116a0d7364985d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converte un codice errore in stringa descrittiva.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Descrizione dettagliata</h2>
<div class="textblock"><p>Classe per il solver dell'algoritmo di Dijkstra migliorato. </p>
<p>Questa classe incapsula tutto il necessario per eseguire l'algoritmo di Dijkstra in modo efficiente e sicuro. Utilizza std::priority_queue per la coda a priorità e gestisce automaticamente la memoria.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md0"></a>
Vantaggi dell'approccio OOP:</h3>
<ul>
<li><b>Incapsulamento</b>: Dati e metodi sono raggruppati logicamente</li>
<li><b>Riusabilità</b>: Un'istanza può essere usata per più calcoli</li>
<li><b>Sicurezza</b>: Gestione automatica della memoria (RAII)</li>
<li><b>Manutenibilità</b>: Codice più organizzato e comprensibile</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1"></a>
Esempio di utilizzo:</h3>
<div class="fragment"><div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    <a class="code hl_function" href="#a7761580b64aa87474eb849fd1d076e63">DijkstraSolver</a> solver(grafo);</div>
<div class="line">    <span class="keyword">auto</span> result = solver.computePaths(1);</div>
<div class="line">    <span class="keywordflow">if</span> (result == <a class="code hl_enumvalue" href="better__dijkstra_8h.html#abb8319303972e8177ba25f0310282cbaad0749aaba8b833466dfcbb0428e4f89c">DijkstraError::SUCCESS</a>) {</div>
<div class="line">        solver.printResults();</div>
<div class="line">        <span class="keyword">auto</span> path = solver.getPath(6);</div>
<div class="line">        solver.printPath(path, 1, 6);</div>
<div class="line">    }</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Errore: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="abetter__dijkstra_8h_html_abb8319303972e8177ba25f0310282cbaad0749aaba8b833466dfcbb0428e4f89c"><div class="ttname"><a href="better__dijkstra_8h.html#abb8319303972e8177ba25f0310282cbaad0749aaba8b833466dfcbb0428e4f89c">DijkstraError::SUCCESS</a></div><div class="ttdeci">@ SUCCESS</div><div class="ttdoc">Esecuzione completata con successo.</div><div class="ttdef"><b>Definition</b> <a href="better__dijkstra_8h_source.html#l00063">better_dijkstra.h:63</a></div></div>
<div class="ttc" id="aclass_dijkstra_solver_html_a7761580b64aa87474eb849fd1d076e63"><div class="ttname"><a href="#a7761580b64aa87474eb849fd1d076e63">DijkstraSolver::DijkstraSolver</a></div><div class="ttdeci">DijkstraSolver(const graph &amp;g)</div><div class="ttdoc">Costruttore che inizializza il solver con un grafo.</div><div class="ttdef"><b>Definition</b> <a href="better__dijkstra_8cc_source.html#l00022">better_dijkstra.cc:22</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definizione alla linea <a class="el" href="better__dijkstra_8h_source.html#l00100">100</a> del file <a class="el" href="better__dijkstra_8h_source.html">better_dijkstra.h</a>.</p>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Documentazione delle ridefinizioni dei tipi (typedef)</h2>
<a id="a84459ce731c874b7e431ee7432e9c49d" name="a84459ce731c874b7e431ee7432e9c49d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84459ce731c874b7e431ee7432e9c49d">&#9670;&#160;</a></span>DistanceNodePair</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a84459ce731c874b7e431ee7432e9c49d">DijkstraSolver::DistanceNodePair</a> = std::pair&lt;float, int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tipo per rappresentare una coppia (distanza, nodo) nella priority queue. </p>
<p>La priority_queue in C++ è un max-heap per default, ma noi vogliamo un min-heap (estrarre sempre il nodo con distanza minima). Usiamo std::greater per invertire l'ordinamento. </p>

<p class="definition">Definizione alla linea <a class="el" href="better__dijkstra_8h_source.html#l00109">109</a> del file <a class="el" href="better__dijkstra_8h_source.html">better_dijkstra.h</a>.</p>

</div>
</div>
<a id="a3131a7b193d0d4e9bc956d97cb7b6fd1" name="a3131a7b193d0d4e9bc956d97cb7b6fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3131a7b193d0d4e9bc956d97cb7b6fd1">&#9670;&#160;</a></span>MinPriorityQueue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a3131a7b193d0d4e9bc956d97cb7b6fd1">DijkstraSolver::MinPriorityQueue</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Valore iniziale:</b><div class="fragment"><div class="line"> std::priority_queue&lt;<a class="code hl_typedef" href="#a84459ce731c874b7e431ee7432e9c49d">DistanceNodePair</a>, </div>
<div class="line">                                               std::vector&lt;DistanceNodePair&gt;, </div>
<div class="line">                                               std::greater&lt;DistanceNodePair&gt;&gt;</div>
<div class="ttc" id="aclass_dijkstra_solver_html_a84459ce731c874b7e431ee7432e9c49d"><div class="ttname"><a href="#a84459ce731c874b7e431ee7432e9c49d">DijkstraSolver::DistanceNodePair</a></div><div class="ttdeci">std::pair&lt; float, int &gt; DistanceNodePair</div><div class="ttdoc">Tipo per rappresentare una coppia (distanza, nodo) nella priority queue.</div><div class="ttdef"><b>Definition</b> <a href="better__dijkstra_8h_source.html#l00109">better_dijkstra.h:109</a></div></div>
</div><!-- fragment -->
<p>Min-heap per estrarre sempre il nodo con distanza minima. </p>
<ul>
<li><b>Template 1</b>: <a class="el" href="#a84459ce731c874b7e431ee7432e9c49d" title="Tipo per rappresentare una coppia (distanza, nodo) nella priority queue.">DistanceNodePair</a> (tipo degli elementi)</li>
<li><b>Template 2</b>: std::vector (container sottostante) <br  />
</li>
<li><b>Template 3</b>: std::greater (comparatore per min-heap) </li>
</ul>

<p class="definition">Definizione alla linea <a class="el" href="better__dijkstra_8h_source.html#l00118">118</a> del file <a class="el" href="better__dijkstra_8h_source.html">better_dijkstra.h</a>.</p>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Documentazione dei costruttori e dei distruttori</h2>
<a id="a7761580b64aa87474eb849fd1d076e63" name="a7761580b64aa87474eb849fd1d076e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7761580b64aa87474eb849fd1d076e63">&#9670;&#160;</a></span>DijkstraSolver() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DijkstraSolver::DijkstraSolver </td>
          <td>(</td>
          <td class="paramtype">const graph &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Costruttore che inizializza il solver con un grafo. </p>
<p>Il costruttore prepara tutte le strutture dati necessarie:</p><ul>
<li>Alloca memoria per distanze e predecessori (RAII)</li>
<li>Inizializza le variabili di stato</li>
<li>Valida il grafo in input</li>
</ul>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Il grafo su cui eseguire l'algoritmo (deve essere valido) </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Eccezioni</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Se il grafo è vuoto o non valido</td></tr>
  </table>
  </dd>
</dl>
<h3 class="doxsection"><a class="anchor" id="autotoc_md3"></a>
Perché RAII è importante:</h3>
<p>RAII (Resource Acquisition Is Initialization) garantisce che:</p><ul>
<li>La memoria viene allocata nel costruttore</li>
<li>La memoria viene automaticamente liberata nel distruttore</li>
<li>Non ci sono memory leak anche in caso di eccezioni </li>
</ul>

<p class="definition">Definizione alla linea <a class="el" href="better__dijkstra_8cc_source.html#l00022">22</a> del file <a class="el" href="better__dijkstra_8cc_source.html">better_dijkstra.cc</a>.</p>

<p class="reference">Referenziato da <a class="el" href="#a533254b95fd3e4a2770ecbf2556c8e61">DijkstraSolver()</a>.</p>

</div>
</div>
<a id="a338bdf5938d0cd6bab3e0e187f3a2dfb" name="a338bdf5938d0cd6bab3e0e187f3a2dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a338bdf5938d0cd6bab3e0e187f3a2dfb">&#9670;&#160;</a></span>~DijkstraSolver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DijkstraSolver::~DijkstraSolver </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Distruttore (gestito automaticamente da std::vector) </p>
<p>Grazie all'uso di std::vector invece di array raw, la memoria viene liberata automaticamente quando l'oggetto viene distrutto. Questo è un esempio di RAII in azione. </p>

</div>
</div>
<a id="a533254b95fd3e4a2770ecbf2556c8e61" name="a533254b95fd3e4a2770ecbf2556c8e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533254b95fd3e4a2770ecbf2556c8e61">&#9670;&#160;</a></span>DijkstraSolver() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DijkstraSolver::DijkstraSolver </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_dijkstra_solver.html">DijkstraSolver</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disabilita copia per evitare problemi con riferimenti. </p>
<p>Siccome la classe mantiene un riferimento al grafo, la copia potrebbe causare problemi. Meglio disabilitarla esplicitamente. </p>

<p class="reference">Referenzia <a class="el" href="better__dijkstra_8cc_source.html#l00022">DijkstraSolver()</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Documentazione delle funzioni membro</h2>
<a id="a0530094ff2b472cd61ae0c434d242991" name="a0530094ff2b472cd61ae0c434d242991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0530094ff2b472cd61ae0c434d242991">&#9670;&#160;</a></span>computePaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="better__dijkstra_8h.html#abb8319303972e8177ba25f0310282cba">DijkstraError</a> DijkstraSolver::computePaths </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esegue l'algoritmo di Dijkstra con gestione errori completa. </p>
<p>Questa è la funzione principale che implementa l'algoritmo di Dijkstra utilizzando std::priority_queue per efficienza ottimale.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md4"></a>
Algoritmo Passo-Passo:</h3>
<ol type="1">
<li><b>Validazione input</b>: Controlla che il nodo sorgente sia valido</li>
<li><b>Controllo archi negativi</b>: Dijkstra funziona solo con pesi ≥ 0</li>
<li><b>Inizializzazione</b>:<ul>
<li>Tutte le distanze = ∞ (FLT_MAX)</li>
<li>Distanza sorgente = 0</li>
<li>Tutti i predecessori = 0 (nessun padre)</li>
</ul>
</li>
<li><b>Coda a priorità</b>: Inserisce il nodo sorgente</li>
<li><b>Ciclo principale</b>: Fino a coda vuota:<ul>
<li>Estrae nodo u con distanza minima</li>
<li>Ignora nodi obsoleti (ottimizzazione)</li>
<li>Per ogni vicino v di u: rilassa l'arco (u,v)</li>
</ul>
</li>
</ol>
<h3 class="doxsection"><a class="anchor" id="autotoc_md5"></a>
Ottimizzazione Lazy Deletion:</h3>
<p>Invece di aggiornare le priorità nella coda (operazione costosa), inseriamo multiple copie dello stesso nodo con distanze diverse. Al momento dell'estrazione, ignoriamo le copie obsolete.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Nodo sorgente (numerato da 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd><a class="el" href="better__dijkstra_8h.html#abb8319303972e8177ba25f0310282cbaad0749aaba8b833466dfcbb0428e4f89c" title="Esecuzione completata con successo.">DijkstraError::SUCCESS</a> se tutto ok, altrimenti codice errore</dd></dl>
<p>@complexity <b>Tempo</b>: O((V + E) log V), <b>Spazio</b>: O(V) </p><dl class="section see"><dt>Si veda anche</dt><dd>validateInput() per la validazione preliminare </dd>
<dd>
relaxEdge() per il rilassamento degli archi </dd></dl>

<p class="definition">Definizione alla linea <a class="el" href="better__dijkstra_8cc_source.html#l00042">42</a> del file <a class="el" href="better__dijkstra_8cc_source.html">better_dijkstra.cc</a>.</p>

<p class="reference">Referenzia <a class="el" href="better__dijkstra_8h_source.html#l00066">MEMORY_ERROR</a>, e <a class="el" href="better__dijkstra_8h_source.html#l00063">SUCCESS</a>.</p>

<p class="reference">Referenziato da <a class="el" href="better__dijkstra_8cc_source.html#l00371">demonstrateBetterDijkstra()</a>.</p>

</div>
</div>
<a id="a59a9850164d41ddf1d116a0d7364985d" name="a59a9850164d41ddf1d116a0d7364985d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a9850164d41ddf1d116a0d7364985d">&#9670;&#160;</a></span>errorToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string DijkstraSolver::errorToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="better__dijkstra_8h.html#abb8319303972e8177ba25f0310282cba">DijkstraError</a></td>          <td class="paramname"><span class="paramname"><em>error</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converte un codice errore in stringa descrittiva. </p>
<p>Utility per convertire i codici di errore enum in messaggi comprensibili per debugging e logging.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Codice di errore da convertire </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd>Stringa descrittiva dell'errore </dd></dl>

<p class="definition">Definizione alla linea <a class="el" href="better__dijkstra_8cc_source.html#l00286">286</a> del file <a class="el" href="better__dijkstra_8cc_source.html">better_dijkstra.cc</a>.</p>

<p class="reference">Referenzia <a class="el" href="better__dijkstra_8h_source.html#l00069">EMPTY_GRAPH</a>, <a class="el" href="better__dijkstra_8h_source.html#l00067">FILE_NOT_FOUND</a>, <a class="el" href="better__dijkstra_8h_source.html#l00068">INVALID_FORMAT</a>, <a class="el" href="better__dijkstra_8h_source.html#l00064">INVALID_SOURCE</a>, <a class="el" href="better__dijkstra_8h_source.html#l00066">MEMORY_ERROR</a>, <a class="el" href="better__dijkstra_8h_source.html#l00065">NEGATIVE_EDGE</a>, e <a class="el" href="better__dijkstra_8h_source.html#l00063">SUCCESS</a>.</p>

<p class="reference">Referenziato da <a class="el" href="better__dijkstra_8cc_source.html#l00371">demonstrateBetterDijkstra()</a>.</p>

</div>
</div>
<a id="a20f6b913f55a3709f2b934500c899b5e" name="a20f6b913f55a3709f2b934500c899b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f6b913f55a3709f2b934500c899b5e">&#9670;&#160;</a></span>getDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float DijkstraSolver::getDistance </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ottiene la distanza minima verso un nodo target. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Nodo di destinazione (numerato da 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd>Distanza minima, o FLT_MAX se non raggiungibile </dd></dl>
<dl class="section pre"><dt>Precondizione</dt><dd>L'algoritmo deve essere stato eseguito (computed_ == true) </dd></dl>

<p class="definition">Definizione alla linea <a class="el" href="better__dijkstra_8cc_source.html#l00148">148</a> del file <a class="el" href="better__dijkstra_8cc_source.html">better_dijkstra.cc</a>.</p>

<p class="reference">Referenziato da <a class="el" href="better__dijkstra_8cc_source.html#l00229">printPath()</a>.</p>

</div>
</div>
<a id="a98e1ac64ec4b2753485b57bb00da14c8" name="a98e1ac64ec4b2753485b57bb00da14c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e1ac64ec4b2753485b57bb00da14c8">&#9670;&#160;</a></span>getPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; DijkstraSolver::getPath </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ricostruisce il percorso minimo verso un nodo target. </p>
<p>Utilizza l'array dei predecessori per ricostruire il percorso all'indietro, dalla destinazione alla sorgente.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6"></a>
Algoritmo di ricostruzione:</h3>
<ol type="1">
<li>Parte dal nodo target</li>
<li>Segue i predecessori: target → pred[target] → pred[pred[target]] → ...</li>
<li>Si ferma quando raggiunge la sorgente (predecessore = 0)</li>
<li>Inverte il percorso per averlo nel verso corretto</li>
</ol>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Nodo di destinazione (numerato da 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd>Vector con il percorso completo (sorgente → ... → target) </dd></dl>
<dl class="section pre"><dt>Precondizione</dt><dd>L'algoritmo deve essere stato eseguito </dd></dl>

<p class="definition">Definizione alla linea <a class="el" href="better__dijkstra_8cc_source.html#l00162">162</a> del file <a class="el" href="better__dijkstra_8cc_source.html">better_dijkstra.cc</a>.</p>

<p class="reference">Referenziato da <a class="el" href="better__dijkstra_8cc_source.html#l00371">demonstrateBetterDijkstra()</a>.</p>

</div>
</div>
<a id="a43da24728dd38e829597c2e81ac59f1f" name="a43da24728dd38e829597c2e81ac59f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43da24728dd38e829597c2e81ac59f1f">&#9670;&#160;</a></span>printPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DijkstraSolver::printPath </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>target</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stampa un percorso specifico in formato leggibile. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Il percorso da stampare </td></tr>
    <tr><td class="paramname">source</td><td>Nodo sorgente </td></tr>
    <tr><td class="paramname">target</td><td>Nodo destinazione </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definizione alla linea <a class="el" href="better__dijkstra_8cc_source.html#l00229">229</a> del file <a class="el" href="better__dijkstra_8cc_source.html">better_dijkstra.cc</a>.</p>

<p class="reference">Referenzia <a class="el" href="better__dijkstra_8cc_source.html#l00148">getDistance()</a>.</p>

<p class="reference">Referenziato da <a class="el" href="better__dijkstra_8cc_source.html#l00371">demonstrateBetterDijkstra()</a>.</p>

</div>
</div>
<a id="a646e23da81edd3088d9b4cd8b7a5e9b2" name="a646e23da81edd3088d9b4cd8b7a5e9b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a646e23da81edd3088d9b4cd8b7a5e9b2">&#9670;&#160;</a></span>printResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DijkstraSolver::printResults </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stampa i risultati in formato tabellare leggibile. </p>
<p>Mostra una tabella con:</p><ul>
<li>Numero nodo</li>
<li>Distanza minima dalla sorgente</li>
<li>Nodo predecessore nel percorso ottimo</li>
</ul>
<dl class="section pre"><dt>Precondizione</dt><dd>L'algoritmo deve essere stato eseguito </dd></dl>

<p class="definition">Definizione alla linea <a class="el" href="better__dijkstra_8cc_source.html#l00195">195</a> del file <a class="el" href="better__dijkstra_8cc_source.html">better_dijkstra.cc</a>.</p>

<p class="reference">Referenziato da <a class="el" href="better__dijkstra_8cc_source.html#l00371">demonstrateBetterDijkstra()</a>.</p>

</div>
</div>
<hr/>La documentazione per questa classe è stata generata a partire dai seguenti file:<ul>
<li><a class="el" href="better__dijkstra_8h_source.html">better_dijkstra.h</a></li>
<li><a class="el" href="better__dijkstra_8cc_source.html">better_dijkstra.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="class_dijkstra_solver.html">DijkstraSolver</a></li>
    <li class="footer">Generato <span class="timestamp"></span> per Algoritmo di Dijkstra - Versione Migliorata da <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
